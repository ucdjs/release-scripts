flowchart TD
    Start([topologicalOrder]) --> BuildGraph[buildGraph(packages)]
    
    BuildGraph --> InitGraph[
        Create maps:<br/>
        - nameToPackage<br/>
        - adjacency<br/>
        - inDegree
    ]
    
    InitGraph --> ConnectDeps[Connect dependencies:<br/>For each pkg's deps,<br/>add edge dep -> pkg]
    
    ConnectDeps --> FindRoots[Find roots:<br/>inDegree === 0]
    
    FindRoots --> InitQueue[Initialize queue<br/>with root packages]
    InitQueue --> InitLevels[levels[root] = 0]
    
    InitLevels --> ProcessQueue[Process queue]
    
    ProcessQueue --> PopPackage[Get next from queue]
    PopPackage --> RecordOrder[Add to ordered<br/>with level]
    
    RecordOrder --> UpdateNeighbors[For each dependent:]
    UpdateNeighbors --> UpdateLevel[
        levels[dep] = max(<br/>
            levels[dep],<br/>
            level + 1<br/>
        )
    ]
    
    UpdateLevel --> Decrement[
        inDegree[dep]--
    ]
    
    Decrement --> CheckZero{inDegree === 0?}
    CheckZero -->|Yes| AddQueue[Add to queue]
    CheckZero -->|No| MoreNeighbors{More dependents?}
    AddQueue --> MoreNeighbors
    
    MoreNeighbors -->|Yes| UpdateNeighbors
    MoreNeighbors -->|No| QueueEmpty{Queue empty?}
    
    QueueEmpty -->|No| ProcessQueue
    QueueEmpty -->|Yes| CheckAll{ordered.length ===<br/>packages.length?}
    
    CheckAll -->|Yes| ReturnOrder[Return ordered<br/>with levels]
    CheckAll -->|No| DetectCycle[
        Find unprocessed<br/>packages
    ]
    DetectCycle --> ThrowCycle[Throw Error:<br/>Cycle detected]
    
    ReturnOrder --> End([End])
    ThrowCycle --> End
    
    style Start fill:#e1f5e1
    style End fill:#e1f5e1
    style ReturnOrder fill:#d4edda
    style ThrowCycle fill:#f8d7da
    style ProcessQueue fill:#fff4e1
    style BuildGraph fill:#e1f0ff
