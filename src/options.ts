import type { GitHubClient } from "#core/github";
import type { CommitTypeRule } from "#shared/types";
import process from "node:process";
import { createGitHubClient } from "#core/github";
import { dedent } from "@luxass/utils";

type DeepRequired<T> = Required<{
  [K in keyof T]: T[K] extends Required<T[K]> ? T[K] : DeepRequired<T[K]>
}>;

export interface FindWorkspacePackagesOptions {
  exclude?: string[];
  include?: string[];
  excludePrivate?: boolean;
}

export interface ReleaseScriptsOptionsInput {
  dryRun?: boolean;
  repo: `${string}/${string}`;
  workspaceRoot?: string;
  packages?: true | FindWorkspacePackagesOptions | string[];
  githubToken: string;
  safeguards?: boolean;
  branch?: {
    release?: string;
    default?: string;
  };
  globalCommitMode?: "dependencies" | "all" | "none";
  pullRequest?: {
    title?: string;
    body?: string;
  };
  types?: Record<string, CommitTypeRule>;
  changelog?: {
    enabled?: boolean;
    template?: string;
    emojis?: boolean;
    combinePrereleaseIntoFirstStable?: boolean;
  };
  npm?: {
    otp?: string;
    provenance?: boolean;
    access?: "public" | "restricted";
  };
  prompts?: {
    versions?: boolean;
    packages?: boolean;
  };
}

export type NormalizedReleaseScriptsOptions = DeepRequired<Omit<ReleaseScriptsOptionsInput, "repo" | "npm" | "prompts">> & {
  owner: string;
  repo: string;
  safeguards: boolean;
  types: Record<string, CommitTypeRule>;
  githubClient: GitHubClient;
  npm: {
    otp?: string;
    provenance: boolean;
    access: "public" | "restricted";
  };
  prompts: {
    versions: boolean;
    packages: boolean;
  };
};

export const DEFAULT_PR_BODY_TEMPLATE = dedent`
  This PR was automatically generated by the UCD release scripts.

  The following packages have been prepared for release:

  <% if (it.packages.length > 0) { %>
  <% it.packages.forEach((pkg) => { %>
  - **<%= pkg.name %>**: <%= pkg.currentVersion %> ‚Üí <%= pkg.newVersion %> (<%= pkg.bumpType %>)
  <% }) %>
  <% } else { %>
  There are no packages to release.
  <% } %>

  Please review the changes and merge when ready.

  > [!NOTE]
  > When this PR is merged, the release process will be triggered automatically, publishing the new package versions to the registry.
`;

export const DEFAULT_CHANGELOG_TEMPLATE = dedent`
  <% if (it.previousVersion) { -%>
  ## [<%= it.version %>](<%= it.compareUrl %>) (<%= it.date %>)
  <% } else { -%>
  ## <%= it.version %> (<%= it.date %>)
  <% } %>
  <% let hasCommits = false; %>

  <% it.groups.forEach((group) => { %>
  <% if (group.commits.length > 0) { %>
  <% hasCommits = true; %>

  ### <%= group.title %>
  <% group.commits.forEach((commit) => { %>

  * <%= commit.line %>
  <% }); %>

  <% } %>
  <% }); %>

  <% if (!hasCommits) { %>
  *No significant changes*

  ##### &nbsp;&nbsp;&nbsp;&nbsp;[View changes on GitHub](<%= it.compareUrl %>)
  <% } %>
`;

export const DEFAULT_TYPES: Record<string, CommitTypeRule> = {
  feat: { title: "üöÄ Features" },
  fix: { title: "üêû Bug Fixes" },
  perf: { title: "üèé Performance" },
  docs: { title: "üìö Documentation" },
  style: { title: "üé® Styles" },
};

export function normalizeReleaseScriptsOptions(options: ReleaseScriptsOptionsInput): NormalizedReleaseScriptsOptions {
  const {
    workspaceRoot = process.cwd(),
    githubToken = "",
    repo: fullRepo,
    packages = true,
    branch = {},
    globalCommitMode = "dependencies",
    pullRequest = {},
    changelog = {},
    types,
    safeguards = true,
    dryRun = false,
    npm = {},
    prompts = {},
  } = options;

  const token = githubToken.trim();
  if (!token) {
    throw new Error("GitHub token is required. Pass it in via options.");
  }

  if (!fullRepo || !fullRepo.trim() || !fullRepo.includes("/")) {
    throw new Error("Repository (repo) is required. Specify in 'owner/repo' format (e.g., 'octocat/hello-world').");
  }

  const [owner, repo] = fullRepo.split("/");
  if (!owner || !repo) {
    throw new Error(`Invalid repo format: "${fullRepo}". Expected format: "owner/repo" (e.g., "octocat/hello-world").`);
  }

  const normalizedPackages = typeof packages === "object" && !Array.isArray(packages)
    ? {
        exclude: packages.exclude ?? [],
        include: packages.include ?? [],
        excludePrivate: packages.excludePrivate ?? false,
      }
    : packages;

  const isCI = process.env.CI === "true" || process.env.GITHUB_ACTIONS === "true";

  return {
    dryRun,
    workspaceRoot,
    githubToken: token,
    owner,
    repo,
    githubClient: createGitHubClient({ owner, repo, githubToken: token }),
    packages: normalizedPackages,
    branch: {
      release: branch.release ?? "release/next",
      default: branch.default ?? "main",
    },
    globalCommitMode,
    safeguards,
    pullRequest: {
      title: pullRequest.title ?? "chore: release new version",
      body: pullRequest.body ?? DEFAULT_PR_BODY_TEMPLATE,
    },
    changelog: {
      enabled: changelog.enabled ?? true,
      template: changelog.template ?? DEFAULT_CHANGELOG_TEMPLATE,
      emojis: changelog.emojis ?? true,
      combinePrereleaseIntoFirstStable: changelog.combinePrereleaseIntoFirstStable ?? false,
    },
    types: types ? { ...DEFAULT_TYPES, ...types } : DEFAULT_TYPES,
    npm: {
      otp: npm.otp,
      provenance: npm.provenance ?? true,
      access: npm.access ?? "public",
    },
    prompts: {
      versions: prompts.versions ?? !isCI,
      packages: prompts.packages ?? !isCI,
    },
  };
}
